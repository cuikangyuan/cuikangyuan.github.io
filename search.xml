<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[数据结构学习笔记-9]]></title>
      <url>http://cuikangyuan.github.io/2016/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-9/</url>
      <content type="html"><![CDATA[<h2 id="u7EA6_u745F_u592B_u73AF"><a href="#u7EA6_u745F_u592B_u73AF" class="headerlink" title="约瑟夫环"></a>约瑟夫环</h2><a id="more"></a> 
<pre><code>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

typedef struct node
{
    int data;
    struct node *next;
}node;

node *create(int n)
{
    node *p = NULL, *head;
    head = (node *)malloc(sizeof(node));
    p = head;
    node *s;
    int i = 1;

    if(0 != n)
    {
        while(i &lt;= n)
        {
            s = (node *)malloc(sizeof(node));
            s-&gt;data = i++;
            p-&gt;next = s;
            p = s;
        }
        s-&gt;next = head-&gt;next;
    }
    free(head);

    return s-&gt;next;
}

int main()
{
    int n = 41;
    int m = 3;
    int i;
    node *p = create(n);
    node *temp;

    m %= n;

    while(p != p-&gt;next)
    {
        for(i=1; i&lt;m-1; i++)
        {
            p = p-&gt;next;
        }

        printf(&quot;%d-&gt;&quot;, p-&gt;next-&gt;data);
        temp = p-&gt;next;
        p-&gt;next = temp-&gt;next;

        free(temp);

        p = p-&gt;next;
    }


    printf(&quot;%d\n&quot;, p-&gt;data);

    return 0;
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构学习笔记-8]]></title>
      <url>http://cuikangyuan.github.io/2016/01/23/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-8/</url>
      <content type="html"><![CDATA[<h2 id="u5FAA_u73AF_u94FE_u8868"><a href="#u5FAA_u73AF_u94FE_u8868" class="headerlink" title="循环链表"></a>循环链表</h2><pre><code>/*链表存储结构的定义*/
typedef struct CLinkList
{
    int data;
    struct CLinkList *next;
}node;
</code></pre><a id="more"></a> 
<pre><code>/*初始化循环链表*/
void ds_init(node **pNode)
{
    int item;
    node *temp;
    node *target;

    printf(&quot;输入结点的值，输入0完成初始化\n&quot;);

    while(1)
    {
        scanf(&quot;%d&quot;, &amp;item);
        fflush(stdin);

        if(item == 0)
            return;

        if((*pNode) == NULL)
        {
            /*循环链表此时只有一个结点*/
            *pNode = (node*)malloc(sizeof(struct CLinkList));
            if(!(*pNode))
                exit(0);
            (*pNode)-&gt;data = item;
            (*pNode)-&gt;next = *pNode;
        }
        else
        {
            /*找到要插入元素的位置*/
            for(target=(*pNode);target-&gt;next!=(*pNode);target=target-&gt;next)
            ;
            /*生成一个新的结点*/
            temp = (node *)malloc(sizeof(struct CLinkList));

            if(!temp)
                exit(0);

            temp-&gt;data = item;
            temp-&gt;next = *pNode;
            target-&gt;next = temp;

        }
    }
}

/*插入结点*/
/*参数: 链表的第一个结点，插入的位置*/
void ds_insert(node **pNode, int i)
{
    node *temp;
    node *target;
    node *p;
    int item;
    int j=1;

    printf(&quot;输入要插入结点的值:&quot;);
    scanf(&quot;%d&quot;, &amp;item);

    if(i == 1)
    {
        //新插入的结点作为第一个结点
        temp = (node *)malloc(sizeof(strut CLinkList));

        if(!temp)
            exit(0);

        temp-&gt;data = item;

        //寻找最后一个结点
        for(target=(*pNode);target-&gt;next!=(*pNode);target=target-&gt;next)
            ;
        temp-&gt;next = (*pNode);
        target-&gt;next = temp;
        *pNode = temp;

    }
    else
    {
        target = *pNode;
        for(; j&lt;(i-1); ++j)
        {
            target = target-&gt;next;
        }
        temp = (node *)malloc(sizeof(struct CLinkList));

        if(!temp)
            exit(0);
        temp-&gt;data = item;
        p = target-&gt;next;
        target-&gt;next = temp;
        temp-&gt;next = p;

    }
}

/*删除结点*/
void ds_delete(node **pNode, int i)
{
    node *target;
    node *temp;

    int j = 1;

    if(i == 1)
    {
        //删除的是第一个结点

        //找到最后一个结点
        for(target=*pNode;target-&gt;next!=*pNode;target=target-&gt;next)
            ;
        temp = *pNode;
        *pNode = (*pNode)-&gt;next;
        target-&gt;next = *pNode;
        free(temp);

    }
    else
    {
        target = *pNode;

        for(; j&lt;i-1; ++j)
        {
            target = target-&gt;next;
        }

        temp = target-&gt;next;
        target-&gt;next = temp-&gt;next;
        free(temp);
    }
}

/*返回结点所在位置*/
int ds_search(node *pNode, int elem)
{
    node *target;
    int i = 1;

    for(target=pNode; target-&gt;data!=elem&amp;&amp;target-&gt;next!=pNode; ++i)
    {
        target = target-&gt;next;
    }

    //表中不存在该元素
    if(target-&gt;next == pNode)
        return -1;
    else
        return i;
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构学习笔记-7]]></title>
      <url>http://cuikangyuan.github.io/2016/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-7/</url>
      <content type="html"><![CDATA[<h2 id="u9762_u8BD5_u9898_u5B9E_u4F8B"><a href="#u9762_u8BD5_u9898_u5B9E_u4F8B" class="headerlink" title="面试题实例"></a>面试题实例</h2><a id="more"></a> 
<pre><code>//快速找到未知长度单链表的中间结点
Status FindMidNode(LinkList L, ElemType *e)
{

    LinkList search, mid;
    mid = search = L;

    while(search-&gt;next != NULL)
    {
        if(search-&gt;next-&gt;next != NULL)
        {
            search = search-&gt;next-&gt;next;

            mid = mid-&gt;next;
        }
        else
        {
            search = search-&gt;next;    
        }
    }

    *e = mid-&gt;data;

    return OK;             
}    
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构学习笔记-6]]></title>
      <url>http://cuikangyuan.github.io/2016/01/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-6/</url>
      <content type="html"><![CDATA[<h2 id="u9759_u6001_u94FE_u8868_u7684_u5220_u9664_u64CD_u4F5C"><a href="#u9759_u6001_u94FE_u8868_u7684_u5220_u9664_u64CD_u4F5C" class="headerlink" title="静态链表的删除操作"></a>静态链表的删除操作</h2><a id="more"></a> 
<pre><code>//将下标为k的空闲结点回收到备用链表
int Free_SLL(StaticLinkList space, int k)
{

    space[k].cur = space[0].cur;
    space[0].cur = k;             
}

/*删除在静态链表L中第i个元素*/
Status ListInsert(StaticLinkList L, int i)
{
    int j, k;

    k = MAX_SIZE - 1; //数组的最后一个元素下标

    if(i&lt;1 || i&gt;ListLength(L)+1)
    {
        retrun ERROR;
    }

    for(j=1; j&lt;=i-1; j++)
    {
        k = L[k].cur;
    }

    j = L[k].cur; //待释放下标
    L[k].cur = L[j].cur;//将释放的位置的前一个结点游标移动

    return OK;             
}

/*返回L中数据元素的个数*/
int ListLength(StaticLinkList L)
{
    int j = 0;
    int i = L[MAX_SIZE-1].cur;//真实存放元素的结点从下标1开始

    while(i)
    {
        i = L[i].cur;//游标移动
        j++;
    }

    return j;

}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构学习笔记-5]]></title>
      <url>http://cuikangyuan.github.io/2016/01/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/</url>
      <content type="html"><![CDATA[<h2 id="u9759_u6001_u94FE_u8868_u7684_u63D2_u5165_u64CD_u4F5C_28C_u8BED_u8A00_u5B9E_u73B0_29"><a href="#u9759_u6001_u94FE_u8868_u7684_u63D2_u5165_u64CD_u4F5C_28C_u8BED_u8A00_u5B9E_u73B0_29" class="headerlink" title="静态链表的插入操作(C语言实现)"></a>静态链表的插入操作(C语言实现)</h2><a id="more"></a> 
<pre><code>//获得空闲分量的下标
int Malloc_SLL(StaticLinkList space)
{

    int i = space[0].cur;
    if(space[0].cur)
    {
        //更新备用分量
        space[0].cur = space[i].cur;
        return i;
    }             
}

/*在静态链表L中第i个元素之前插入新的数据元素e*/
Status ListInsert(StaticLinkList L, int i, ElemType e)
{
    int j, k, l;

    k = MAX_SIZE - 1; //数组的最后一个元素下标

    if(i&lt;1 || i&gt;ListLength(L)+1)
    {
        retrun ERROR;
    }

    j = Malloc_SLL(L);
    if(j)
    {
        L[j].data = e;
        for(l=1; l&lt;=i-1; l++)
        {
            k = L[k].cur;
        }
        L[j].cur = L[k].cur;
        L[k].cur = j;

        return OK;
    }

    return ERROR;             
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构学习笔记-4]]></title>
      <url>http://cuikangyuan.github.io/2016/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/</url>
      <content type="html"><![CDATA[<pre><code> typedef struct Node
{
    ElemType data;       //数据域
    struct Node* Next;   //存放后继结点地址
} Node;

typedef struct Node* LinkList
</code></pre><h2 id="u5355_u94FE_u8868_u6574_u8868_u5220_u9664_28C_u8BED_u8A00_u5B9E_u73B0_29"><a href="#u5355_u94FE_u8868_u6574_u8868_u5220_u9664_28C_u8BED_u8A00_u5B9E_u73B0_29" class="headerlink" title="单链表整表删除(C语言实现)"></a>单链表整表删除(C语言实现)</h2><a id="more"></a> 
<pre><code>void ClearList(LinkList *L)
{

    LinkList p, q;

    p = (*L)-&gt;next;

    while(p)
    {
        q = p-&gt;next;
        free(p);
        p = q;
    }
    (*L)-&gt;next = NULL;

    return OK;        
 }
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构学习笔记-3]]></title>
      <url>http://cuikangyuan.github.io/2016/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
      <content type="html"><![CDATA[<pre><code> typedef struct Node
{
    ElemType data;       //数据域
    struct Node* Next;   //存放后继结点地址
} Node;

typedef struct Node* LinkList
</code></pre><h2 id="u5934_u63D2_u6CD5_u5EFA_u7ACB_u5355_u94FE_u8868_28C_u8BED_u8A00_u5B9E_u73B0_29"><a href="#u5934_u63D2_u6CD5_u5EFA_u7ACB_u5355_u94FE_u8868_28C_u8BED_u8A00_u5B9E_u73B0_29" class="headerlink" title="头插法建立单链表(C语言实现)"></a>头插法建立单链表(C语言实现)</h2><a id="more"></a> 
<pre><code>void CreateListFromHead(LinkList *L, int n)
{

    LinkList p;
    int i;

    srand(time(0)); //初始化随机种子

    *L = (LinkList)malloc(sizeof(Node));
    (*L)-&gt;next = NULL;

    for(i=0; i&lt;n; i++)
    {
        p = (LinkList)malloc(sizeof(Node));
        p-&gt;data = rand()%100+1;
        p-&gt;next = (*L)-&gt;next;
        (*L)-&gt;next = p;
    }        
 }
</code></pre><h2 id="u5C3E_u63D2_u6CD5_u5EFA_u7ACB_u5355_u94FE_u8868_28C_u8BED_u8A00_u5B9E_u73B0_29"><a href="#u5C3E_u63D2_u6CD5_u5EFA_u7ACB_u5355_u94FE_u8868_28C_u8BED_u8A00_u5B9E_u73B0_29" class="headerlink" title="尾插法建立单链表(C语言实现)"></a>尾插法建立单链表(C语言实现)</h2><pre><code>void CreateListFromTail(LinkList *L, int n)
{

    LinkList p,r;
    int i;

    srand(time(0)); //初始化随机种子

    *L = (LinkList)malloc(sizeof(Node));
    r = *L

    for(i=0; i&lt;n; i++)
    {
        p = (LinkList)malloc(sizeof(Node));
        p-&gt;data = rand()%100+1;

        r-&gt;next = p;
        r = p;
    }

    r-&gt;next = NULL;        
 }
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构学习笔记-2]]></title>
      <url>http://cuikangyuan.github.io/2016/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
      <content type="html"><![CDATA[<pre><code> typedef struct Node
{
    ElemType data;       //数据域
    struct Node* Next;   //存放后继结点地址
} Node;

typedef struct Node* LinkList
</code></pre><h2 id="u5355_u94FE_u8868_u63D2_u5165_28C_u8BED_u8A00_u5B9E_u73B0_29"><a href="#u5355_u94FE_u8868_u63D2_u5165_28C_u8BED_u8A00_u5B9E_u73B0_29" class="headerlink" title="单链表插入(C语言实现)"></a>单链表插入(C语言实现)</h2><a id="more"></a> 
<pre><code>Status ListInsert(LinkList L, int i, ElemType e)
{
    int j;
    LinkList p, s;

    p = L;
    j = 1;

    while(p &amp;&amp; j&lt;i)
    {
        p = p-&gt;Next;
        ++j;
    }

    if(!p || j&gt;i)
    {
        return ERROR;
    }

    s = (LinkList)malloc(sizeof(Node));
    s-&gt;data = e;

    s-&gt;next = p-&gt;next;
    p-&gt;next = s;

    return OK;        
 }
</code></pre><h2 id="u5355_u94FE_u8868_u5220_u9664_28C_u8BED_u8A00_u5B9E_u73B0_29"><a href="#u5355_u94FE_u8868_u5220_u9664_28C_u8BED_u8A00_u5B9E_u73B0_29" class="headerlink" title="单链表删除(C语言实现)"></a>单链表删除(C语言实现)</h2><pre><code>Status ListInsert(LinkList L, int i, ElemType *e)
{
    int j;
    LinkList p, q;

    p = L;
    j = 1;

    while(p &amp;&amp; j&lt;i)
    {
        p = p-&gt;Next;
        ++j;
    }

    if(!(p-&gt;next) || j&gt;i)
    {
        return ERROR;
    }

    q = p-&gt;next;
    p-&gt;next = q-&gt;next;


    *e = q-&gt;data;
    free(q);

    return OK;        
 }
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构学习笔记-1]]></title>
      <url>http://cuikangyuan.github.io/2016/01/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      <content type="html"><![CDATA[<pre><code> typedef struct Node
{
    ElemType data;       //数据域
    struct Node* Next;   //存放后继结点地址
} Node;

typedef struct Node* LinkList
</code></pre><h2 id="u83B7_u53D6_u94FE_u8868_u5143_u7D20_u7B97_u6CD5_28C_u8BED_u8A00_u5B9E_u73B0_29"><a href="#u83B7_u53D6_u94FE_u8868_u5143_u7D20_u7B97_u6CD5_28C_u8BED_u8A00_u5B9E_u73B0_29" class="headerlink" title="获取链表元素算法(C语言实现)"></a>获取链表元素算法(C语言实现)</h2><a id="more"></a> 
<pre><code>Status GetElem(LinkList L, int i, ElemType *e)
{
    int j;
    LinkList p;

    p = L-&gt;Next
    j = 1;

    while(p &amp;&amp; j&lt;i)
    {
        p = p-&gt;Next;
        ++j;
    }

    if(!p || j&gt;i)
    {
        return ERROR;
    }
    *e = p-&gt;data;

    return OK;        
 }
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo搭建博客时的备忘]]></title>
      <url>http://cuikangyuan.github.io/2016/01/04/Hexo%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      <content type="html"><![CDATA[<p>在用Hexo+Github搭建个人博客时，注意在配置Deploy时要使用SSH地址而不是Https，否则可能无法上传到Github。<br>推荐以下教程：<a href="http://jingyan.baidu.com/article/d8072ac47aca0fec95cefd2d.html" target="_blank" rel="external">Click Here</a></p>
]]></content>
    </entry>
    
  
  
</search>
