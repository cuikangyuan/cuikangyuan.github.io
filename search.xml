<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[数据结构学习笔记-5]]></title>
      <url>http://cuikangyuan.github.io/2016/01/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-5/</url>
      <content type="html"><![CDATA[<h2 id="u9759_u6001_u94FE_u8868_u7684_u63D2_u5165_u64CD_u4F5C_28C_u8BED_u8A00_u5B9E_u73B0_29"><a href="#u9759_u6001_u94FE_u8868_u7684_u63D2_u5165_u64CD_u4F5C_28C_u8BED_u8A00_u5B9E_u73B0_29" class="headerlink" title="静态链表的插入操作(C语言实现)"></a>静态链表的插入操作(C语言实现)</h2><pre><code>//获得空闲分量的下标
int Malloc_SLL(StaticLinkList space)
{

    int i = space[0].cur;
    if(space[0].cur)
    {
        //更新备用分量
        space[0].cur = space[i].cur;
        return i;
    }             
}

/*在静态链表L中第i个元素之前插入新的数据元素e*/
Status ListInsert(StaticLinkList L, int i, ElemType e)
{
    int j, k, l;

    k = MAX_SIZE - 1; //数组的最后一个元素下标

    if(i&lt;1 || i&gt;ListLength(L)+1)
    {
        retrun ERROR;
    }

    j = Malloc_SLL(L);
    if(j)
    {
        L[j].data = e;
        for(l=1; l&lt;=i-1; l++)
        {
            k = L[k].cur;
        }
        L[j].cur = L[k].cur;
        L[k].cur = j;

        return OK;
    }

    return ERROR;             
}
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构学习笔记-4]]></title>
      <url>http://cuikangyuan.github.io/2016/01/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-4/</url>
      <content type="html"><![CDATA[<pre><code> typedef struct Node
{
    ElemType data;       //数据域
    struct Node* Next;   //存放后继结点地址
} Node;

typedef struct Node* LinkList
</code></pre><h2 id="u5355_u94FE_u8868_u6574_u8868_u5220_u9664_28C_u8BED_u8A00_u5B9E_u73B0_29"><a href="#u5355_u94FE_u8868_u6574_u8868_u5220_u9664_28C_u8BED_u8A00_u5B9E_u73B0_29" class="headerlink" title="单链表整表删除(C语言实现)"></a>单链表整表删除(C语言实现)</h2><pre><code>void ClearList(LinkList *L)
{

    LinkList p, q;

    p = (*L)-&gt;next;

    while(p)
    {
        q = p-&gt;next;
        free(p);
        p = q;
    }
    (*L)-&gt;next = NULL;

    return OK;        
 }
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构学习笔记-3]]></title>
      <url>http://cuikangyuan.github.io/2016/01/10/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-3/</url>
      <content type="html"><![CDATA[<pre><code> typedef struct Node
{
    ElemType data;       //数据域
    struct Node* Next;   //存放后继结点地址
} Node;

typedef struct Node* LinkList
</code></pre><h2 id="u5934_u63D2_u6CD5_u5EFA_u7ACB_u5355_u94FE_u8868_28C_u8BED_u8A00_u5B9E_u73B0_29"><a href="#u5934_u63D2_u6CD5_u5EFA_u7ACB_u5355_u94FE_u8868_28C_u8BED_u8A00_u5B9E_u73B0_29" class="headerlink" title="头插法建立单链表(C语言实现)"></a>头插法建立单链表(C语言实现)</h2><pre><code>void CreateListFromHead(LinkList *L, int n)
{

    LinkList p;
    int i;

    srand(time(0)); //初始化随机种子

    *L = (LinkList)malloc(sizeof(Node));
    (*L)-&gt;next = NULL;

    for(i=0; i&lt;n; i++)
    {
        p = (LinkList)malloc(sizeof(Node));
        p-&gt;data = rand()%100+1;
        p-&gt;next = (*L)-&gt;next;
        (*L)-&gt;next = p;
    }        
 }
</code></pre><h2 id="u5C3E_u63D2_u6CD5_u5EFA_u7ACB_u5355_u94FE_u8868_28C_u8BED_u8A00_u5B9E_u73B0_29"><a href="#u5C3E_u63D2_u6CD5_u5EFA_u7ACB_u5355_u94FE_u8868_28C_u8BED_u8A00_u5B9E_u73B0_29" class="headerlink" title="尾插法建立单链表(C语言实现)"></a>尾插法建立单链表(C语言实现)</h2><pre><code>void CreateListFromTail(LinkList *L, int n)
{

    LinkList p,r;
    int i;

    srand(time(0)); //初始化随机种子

    *L = (LinkList)malloc(sizeof(Node));
    r = *L

    for(i=0; i&lt;n; i++)
    {
        p = (LinkList)malloc(sizeof(Node));
        p-&gt;data = rand()%100+1;

        r-&gt;next = p;
        r = p;
    }

    r-&gt;next = NULL;        
 }
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构学习笔记-2]]></title>
      <url>http://cuikangyuan.github.io/2016/01/06/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
      <content type="html"><![CDATA[<pre><code> typedef struct Node
{
    ElemType data;       //数据域
    struct Node* Next;   //存放后继结点地址
} Node;

typedef struct Node* LinkList
</code></pre><h2 id="u5355_u94FE_u8868_u63D2_u5165_28C_u8BED_u8A00_u5B9E_u73B0_29"><a href="#u5355_u94FE_u8868_u63D2_u5165_28C_u8BED_u8A00_u5B9E_u73B0_29" class="headerlink" title="单链表插入(C语言实现)"></a>单链表插入(C语言实现)</h2><a id="more"></a> 
<pre><code>Status ListInsert(LinkList L, int i, ElemType e)
{
    int j;
    LinkList p, s;

    p = L;
    j = 1;

    while(p &amp;&amp; j&lt;i)
    {
        p = p-&gt;Next;
        ++j;
    }

    if(!p || j&gt;i)
    {
        return ERROR;
    }

    s = (LinkList)malloc(sizeof(Node));
    s-&gt;data = e;

    s-&gt;next = p-&gt;next;
    p-&gt;next = s;

    return OK;        
 }
</code></pre><h2 id="u5355_u94FE_u8868_u5220_u9664_28C_u8BED_u8A00_u5B9E_u73B0_29"><a href="#u5355_u94FE_u8868_u5220_u9664_28C_u8BED_u8A00_u5B9E_u73B0_29" class="headerlink" title="单链表删除(C语言实现)"></a>单链表删除(C语言实现)</h2><pre><code>Status ListInsert(LinkList L, int i, ElemType *e)
{
    int j;
    LinkList p, q;

    p = L;
    j = 1;

    while(p &amp;&amp; j&lt;i)
    {
        p = p-&gt;Next;
        ++j;
    }

    if(!(p-&gt;next) || j&gt;i)
    {
        return ERROR;
    }

    q = p-&gt;next;
    p-&gt;next = q-&gt;next;


    *e = q-&gt;data;
    free(q);

    return OK;        
 }
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[数据结构学习笔记-1]]></title>
      <url>http://cuikangyuan.github.io/2016/01/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      <content type="html"><![CDATA[<pre><code> typedef struct Node
{
    ElemType data;       //数据域
    struct Node* Next;   //存放后继结点地址
} Node;

typedef struct Node* LinkList
</code></pre><h2 id="u83B7_u53D6_u94FE_u8868_u5143_u7D20_u7B97_u6CD5_28C_u8BED_u8A00_u5B9E_u73B0_29"><a href="#u83B7_u53D6_u94FE_u8868_u5143_u7D20_u7B97_u6CD5_28C_u8BED_u8A00_u5B9E_u73B0_29" class="headerlink" title="获取链表元素算法(C语言实现)"></a>获取链表元素算法(C语言实现)</h2><a id="more"></a> 
<pre><code>Status GetElem(LinkList L, int i, ElemType *e)
{
    int j;
    LinkList p;

    p = L-&gt;Next
    j = 1;

    while(p &amp;&amp; j&lt;i)
    {
        p = p-&gt;Next;
        ++j;
    }

    if(!p || j&gt;i)
    {
        return ERROR;
    }
    *e = p-&gt;data;

    return OK;        
 }
</code></pre>]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[Hexo搭建博客时的备忘]]></title>
      <url>http://cuikangyuan.github.io/2016/01/04/Hexo%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</url>
      <content type="html"><![CDATA[<p>在用Hexo+Github搭建个人博客时，注意在配置Deploy时要使用SSH地址而不是Https，否则可能无法上传到Github。<br>推荐以下教程：<a href="http://jingyan.baidu.com/article/d8072ac47aca0fec95cefd2d.html" target="_blank" rel="external">Click Here</a></p>
]]></content>
    </entry>
    
  
  
</search>
